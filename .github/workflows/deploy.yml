name: Deploy

on:
  push:
    branches:
      - master
  workflow_dispatch:

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    permissions:
      contents: read
    outputs:
      image_tag: ${{ steps.meta.outputs.image_tag }}
    steps:
      - uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Prepare image metadata
        id: meta
        run: |
          IMAGE_TAG="sha-${GITHUB_SHA::12}"
          echo "image_tag=$IMAGE_TAG" >> "$GITHUB_OUTPUT"
          echo "tags=gazzati/dzera-bot:$IMAGE_TAG,gazzati/dzera-bot:latest" >> "$GITHUB_OUTPUT"

      - name: Build and push
        uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  deploy:
    runs-on: ubuntu-latest
    needs: build-and-push
    steps:
      - name: Deploy to server
        uses: appleboy/ssh-action@v1
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script: |
            cd /home/tim/dzera-bot
            if [ ! -f .env ]; then
              echo "Missing required file: .env"
              exit 1
            fi
            if [ ! -f google-credentials.json ]; then
              echo "Missing required file: google-credentials.json"
              exit 1
            fi
            echo "IMAGE_TAG=${{ needs.build-and-push.outputs.image_tag }}" > .env.deploy
            docker compose --env-file .env --env-file .env.deploy pull dzera-bot
            docker compose --env-file .env --env-file .env.deploy up -d --no-deps dzera-bot

  cleanup-old-tags:
    runs-on: ubuntu-latest
    needs: deploy
    if: ${{ needs.deploy.result == 'success' }}
    steps:
      - name: Remove old Docker Hub sha tags
        env:
          DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
          DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}
          IMAGE_NAMESPACE: gazzati
          IMAGE_REPOSITORY: dzera-bot
          KEEP_SHA_TAGS: "10"
        run: |
          python - <<'PY'
          import json
          import os
          import urllib.error
          import urllib.request

          username = os.environ["DOCKERHUB_USERNAME"]
          password = os.environ["DOCKERHUB_TOKEN"]
          namespace = os.environ["IMAGE_NAMESPACE"]
          repository = os.environ["IMAGE_REPOSITORY"]
          keep_count = int(os.environ["KEEP_SHA_TAGS"])

          def request_json(method, url, payload=None, token=None):
              data = None
              headers = {"Content-Type": "application/json"}
              if token:
                  headers["Authorization"] = f"Bearer {token}"
              if payload is not None:
                  data = json.dumps(payload).encode("utf-8")
              req = urllib.request.Request(url, data=data, headers=headers, method=method)
              with urllib.request.urlopen(req) as resp:
                  body = resp.read().decode("utf-8")
                  return json.loads(body) if body else {}

          login = request_json(
              "POST",
              "https://hub.docker.com/v2/users/login/",
              {"username": username, "password": password},
          )
          token = login.get("token")
          if not token:
              raise RuntimeError("Docker Hub auth failed: token was not returned")

          tags = []
          url = f"https://hub.docker.com/v2/namespaces/{namespace}/repositories/{repository}/tags?page_size=100"
          while url:
              page = request_json("GET", url, token=token)
              tags.extend(page.get("results", []))
              url = page.get("next")

          sha_tags = [t for t in tags if t.get("name", "").startswith("sha-")]
          sha_tags.sort(key=lambda t: t.get("last_updated", ""), reverse=True)
          tags_to_delete = sha_tags[keep_count:]

          if not tags_to_delete:
              print(f"No old sha tags to delete. Found {len(sha_tags)} sha tags, keep limit is {keep_count}.")
              raise SystemExit(0)

          print(f"Deleting {len(tags_to_delete)} old sha tags (keeping {keep_count}).")
          deleted = 0
          failed = []

          for tag in tags_to_delete:
              name = tag["name"]
              delete_url = f"https://hub.docker.com/v2/namespaces/{namespace}/repositories/{repository}/tags/{name}/"
              req = urllib.request.Request(
                  delete_url,
                  headers={"Authorization": f"Bearer {token}"},
                  method="DELETE",
              )
              try:
                  with urllib.request.urlopen(req):
                      deleted += 1
                      print(f"Deleted tag: {name}")
              except urllib.error.HTTPError as exc:
                  failed.append((name, exc.code))
                  print(f"Failed to delete tag {name}: HTTP {exc.code}")

          if failed:
              raise RuntimeError(f"Deleted {deleted} tags, but {len(failed)} deletions failed: {failed}")

          print(f"Deleted {deleted} old sha tags successfully.")
          PY
